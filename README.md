## SwiftUI Thinking Intermediate code Î™®Ïùå

### üëâ [Í∞ïÏùò Ï±ÑÎÑê Î∞îÎ°úÍ∞ÄÍ∏∞](https://www.youtube.com/playlist?list=PLwvDm4VfkdpiagxAXCT33Rkwnc5IVhTar)

---

### 01.onLongPressGesture

The tap gesture when you tap on it the action occurs immediately as soon as you tap on it

Teh long press gesture we can set an amount of time that we need to tap and hold or press and hold before the action executes

```swift
struct LongPressGestureBootCamp: View {
// MARK: -  PROPERTY

@State var isComplete: Bool = false

// MARK: -  BODY
var body: some View {
  Text(isComplete ? "COMPLETED" : "NOT COMPLETE")
    .padding()
    .padding(.horizontal)
    .background(isComplete ? Color.green : Color.gray)
    .cornerRadius(10)
  // click button and immediately changed color
    // .onTapGesture {
    // 	isComplete.toggle()
    // }
  // if click and hold for about on second it will switch
  // maximumDistance is move user finger witin 50 points and it should still work
    .onLongPressGesture(minimumDuration: 1.0, maximumDistance: 50) {
      isComplete.toggle()
    }
}
}

```

  <img height="350"  alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫" src="https://user-images.githubusercontent.com/28912774/156956561-f995e6f8-6224-4919-8615-aee40912e743.gif">

```swift
struct LongPressGestureBootCamp: View {
// MARK: -  PROPERTY

@State var isComplete: Bool = false
@State var isSuccess: Bool = false

// MARK: -  BODY
var body: some View {
VStack {
Rectangle()
.fill(isSuccess ? Color.green : Color.blue)
.frame(maxWidth: isComplete ? .infinity : 0)
.frame(height: 55)
.frame(maxWidth: .infinity, alignment: .leading)
.background(Color.gray)

HStack {
Text("CLICK HERE")
.foregroundColor(.white)
.padding()
.background(Color.black)
.cornerRadius(10)
.onLongPressGesture(minimumDuration: 1.0, maximumDistance: 50) { (isPressing) in
  // start of press -> min duration
  if isPressing {
    withAnimation(.easeInOut(duration: 1.0)) {
      isComplete = true
    }
  } else {
    DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
      if !isSuccess {
        withAnimation(.easeInOut) {
          isComplete = false
        }
      }
    }
  }

} perform: {
  // at the min duration
  withAnimation(.easeInOut) {
    isSuccess = true
  }
}

Text("RESET")
.foregroundColor(.white)
.padding()
.background(Color.black)
.cornerRadius(10)
.onTapGesture {
  isComplete = false
  isSuccess = false
}
}
} //: VSTACK
}
}
```

  <img height="350"  alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫" src="https://user-images.githubusercontent.com/28912774/156958039-d2e24e86-f380-463f-a51e-37fb5025629d.gif">

---

### 02.MagnificationGesture

magnification gesture basically the zoom in and out gesture that you use on the map on your iphone. if you have instagram you can zoom in on pictures that is a magnification gesture

```swift
struct MagnificationGestureBootCamp: View {
// MARK: -  PROPERTY

@State var currentAmount: CGFloat = 0
@State var lastAmount: CGFloat = 0

// MARK: -  BODY
var body: some View {
Text("Hello, World!")
.font(.title)
.padding(40)
.background(Color.red)
.cornerRadius(10)
.scaleEffect(1 + currentAmount + lastAmount)
.gesture(
  MagnificationGesture()
    .onChanged({ value in
      currentAmount = value - 1
    })
    .onEnded({ value in
      lastAmount += currentAmount
      currentAmount = 0
    })

)
}
}
```

  <img height="350"  alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫" src="https://user-images.githubusercontent.com/28912774/156959748-1604953e-0397-40a7-8cc3-c105a5aefbeb.gif">

```swift

@State var currentAmount: CGFloat = 0

// MARK: -  BODY
var body: some View {
VStack (spacing: 10) {

HStack {
  Circle().frame(width: 35, height: 35)
  Text("SwiftUI Thinking")
  Spacer()
  Image(systemName: "ellipsis")
} //: HSTACK
.padding(.horizontal)

Rectangle()
  .frame(height: 300)
  .scaleEffect(1 + currentAmount)
  .gesture(
    MagnificationGesture()
      .onChanged({ value in
        currentAmount = value - 1
      })
      .onEnded({ value in
        withAnimation(.spring()) {
          currentAmount = 0
        }
      })
  )

HStack {
  Image(systemName: "heart.fill")
  Image(systemName: "text.bubble.fill")
  Spacer()
} //: HSTACK
.padding(.horizontal)
.font(.headline)

Text("This is the caption for my photo!")
  .frame(maxWidth: .infinity, alignment: .leading)
  .padding(.horizontal)
} //: VSTACK
}
}
```

  <img height="350"  alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫" src="https://user-images.githubusercontent.com/28912774/156960792-f55f2b76-debe-44ed-8ab0-12c04f404f5e.gif">

---

### 03.RotationGesture

Rotation gesture is when you have two fingers on the device and you rotating an object and we can use it to rotate images, rotate text or rotate pretty much anything that we want on our swiftUI application

```swift
struct RotationGestrueBootCamp: View {
// MARK: -  PROPERTY

@State var angle: Angle = Angle(degrees: 0)

// MARK: -  BODY
var body: some View {
Text("Hello, World!")
.font(.largeTitle)
.fontWeight(.semibold)
.foregroundColor(.white)
.padding(50)
.background(Color.blue)
.cornerRadius(10)
.rotationEffect(angle)
.gesture(
  RotationGesture()
    .onChanged({ value in
      angle = value
    })
    .onEnded({ value in
      withAnimation(.spring()) {
        angle = Angle(degrees: 0)
      }
    })
)
}
}
```

  <img height="350"  alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫" src="https://user-images.githubusercontent.com/28912774/156961759-14048266-1a21-452d-a7a5-4cd4c10d3124.gif">

---

### 04.DragGesture

The drag gesture is what it sounds like it's when you drag something around the screen. It is really cool features such as swiping on cards if you could use a drag gesture to swipe the cards left and right drag gesture to swipe up or swipe down different screens in our app

```swift
struct DragGestureBootCamp: View {
// MARK: -  PROPERTY

@State var offset: CGSize = .zero

// MARK: -  BODY
var body: some View {
ZStack {

VStack {
Text("\(offset.width)")
Spacer()
} //: VSTACK

RoundedRectangle(cornerRadius: 20)
.frame(width: 300, height: 500)
.offset(offset)
.scaleEffect(getScaleAmount())
.rotationEffect(Angle(degrees: getRotationAmount()))
.gesture(
DragGesture()
  .onChanged({ value in
    withAnimation(.spring()) {
      offset = value.translation
    }
  })
  .onEnded({ value in
    withAnimation(.spring()) {
      offset = .zero
    }
  })
)
} //: ZSTACK
}

// MARK: -  FUNCTION
func getScaleAmount() -> CGFloat {
  let max = UIScreen.main.bounds.width / 2
  // Ï†àÎåÄÍ∞íÏúºÎ°ú abs Î∂ôÏó¨Ï§å
  let currentAmount = abs(offset.width)
  let percentage = currentAmount / max
  // ÏµúÏÜå Í∞íÏù¥ 0.5 ÏóêÏÑú Ï≤úÏ≤úÌûà Î≥ÄÌïòÍ∏∞ ÏúÑÌï¥ * 0.5 Ìï¥Ï§å
  return 1.0 - min(percentage, 0.5) * 0.5
}

func getRotationAmount() -> Double {
  let max = UIScreen.main.bounds.width / 2
  let currentAmount = offset.width
  let percentage = currentAmount / max
  let percentageAsDouble  = Double(percentage)
  let maxAngle: Double = 10
  return percentageAsDouble * maxAngle
}
}
```

<img height="350"  alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫" src="https://user-images.githubusercontent.com/28912774/157175819-34accd0b-a501-4f57-be49-986a721ac8b4.gif">

```swift
struct DragGestureBootCamp2: View {
// MARK: -  PROPERTY

@State var startOffsetY: CGFloat = UIScreen.main.bounds.height * 0.85
@State var currentDragOffsetY: CGFloat = 0
@State var endingOffsetY: CGFloat = 0

// MARK: -  BODY
var body: some View {
ZStack {
// Background
Color.green.ignoresSafeArea()

// Foreground
MySingUpView()
.offset(y: startOffsetY)
.offset(y: currentDragOffsetY)
.offset(y: endingOffsetY)
.gesture(
DragGesture()
.onChanged({ value in
  withAnimation(.spring()) {
    currentDragOffsetY = value.translation.height
  }
})
.onEnded({ value in
  withAnimation(.spring()) {
    if currentDragOffsetY < -150 {
      // cancel offset
      endingOffsetY = -startOffsetY
    } else if endingOffsetY != 0 && currentDragOffsetY > 150 {
      endingOffsetY = 0
    }
    currentDragOffsetY = 0
  }
})
)

Text("\(currentDragOffsetY)")
} //: ZSTACK
.ignoresSafeArea(edges: .bottom)
}
}

// MARK: -  PREVIEW
struct DragGestureBootCamp2_Previews: PreviewProvider {
static var previews: some View {
DragGestureBootCamp2()
}
}


// MARK: -  EXTENSION
struct MySingUpView: View {
var body: some View {
VStack (spacing: 20) {
  Image(systemName: "chevron.up")
    .padding(.top)
  Text("Sign up")
    .font(.headline)
    .fontWeight(.semibold)

  Image(systemName: "flame.fill")
    .resizable()
    .scaledToFit()
    .frame(width: 100, height: 100)

  Text("This is the decription for our app. This is my favorite SwiftUI course and I recommend to all of my fiends to subscribe to SwiftUI Thinking!")
    .multilineTextAlignment(.center)

  Text("Create An Account")
    .foregroundColor(.white)
    .font(.headline)
    .padding()
    .padding(.horizontal)
    .background(Color.black.cornerRadius(10))

  Spacer()
} //: VSTACK
.frame(maxWidth: .infinity)
.background(Color.white)
.cornerRadius(30)
}
}
```

  <img height="350"  alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫" src="https://user-images.githubusercontent.com/28912774/157179054-386adbf1-c18f-41eb-84e4-9e4550656a7f.gif">

---

### 05.ScrollViewReader

When we add a very basic scroll view to application we can scroll manually up and down but we cannot automatically scroll to the bottom or scroll to the middle or scroll anywhere automatically in that scroll view

In ScrollViewReader to th app can add features to automatically scroll to the bottom of our scroll view or to any certain point in our scroll view

```swift
struct ScrollViewReaderBootCamp: View {
// MARK: -  PROPERTY
@State var scrollToIndex: Int = 0
@State var textFieldText: String = ""

// MARK: -  BODY
var body: some View {
VStack {
TextField("Ender a # here", text: $textFieldText)
.frame(height: 55)
.border(Color.gray)
.padding(.horizontal)
.keyboardType(.numberPad)

Button {
withAnimation(.easeInOut) {
if let index = Int(textFieldText) {
  scrollToIndex = index
}
}
} label: {
Text("Scroll Now")
}

ScrollView {
// proxy is basically reading the size of the scroll view
ScrollViewReader { proxy in
ForEach(0..<50) { index in
  Text("This is item #\(index)")
    .frame(height: 200)
    .frame(maxWidth: .infinity)
    .background(Color.white)
    .cornerRadius(10)
    .shadow(radius: 10)
    .padding()
    .id(index)
} //: LOOP
.onChange(of: scrollToIndex) { newValue in
  withAnimation(.spring()) {
    proxy.scrollTo(newValue, anchor: .top)
  }
}
} //: SCROLLREADER
} //: SCROLL
} //: VSTACK
}
}
```

  <img height="350"  alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫" src="https://user-images.githubusercontent.com/28912774/157370971-3716cd7a-6834-4654-b421-3eb620ecf3ad.gif">

---

### 06.GeometryReader

Using GeometryReader we can basically get the exact size and location of objects on the screen.

Sometimes when you are building complex applications you do want make sure certain things are specific sizes or maybe specific locations on your app an to do that we can use the geometry reader

GeometryReader is very expensive it costs a lot of computing power to use and you put too many geometry readers and the geometries are doing a lot of tasks on the screen

```swift
struct GeometryReaderBootCamp: View {

// MARK: -  BODY
var body: some View {
// geometry which is the size basically of the content that's inside it
GeometryReader { geometry in
HStack (spacing: 0) {
  Rectangle()
    .fill(Color.red)
  //  UIScreen.main.bounds.width ÏúºÎ°ú ÌÅ¨Í∏∞Î•º ÏÑ§Ï†ïÌïòÎ©¥ rotation Ìï†Îïå ÌÅ¨Í∏∞Í∞Ä Í≥†Ï†ïÎêòÏßÄ ÏïäÏùå
    // .frame(width: UIScreen.main.bounds.width * 0.6666)
    // GeometryReader Î•º ÏÇ¨Ïö©ÌïòÎ©¥ rotation ÎêòÎèÑ Í∞ôÏùÄ ÏÑ§Ï†ïÏúºÎ°ú Ïú†ÏßÄÎê®
    .frame(width: geometry.size.width * 0.6666)
  Rectangle()
    .fill(Color.blue)
} //: HSTACK
.ignoresSafeArea()
}
}
}
```

![Kapture 2022-03-09 at 13 31 56](https://user-images.githubusercontent.com/28912774/157373187-08b4bef0-c721-4253-bb6b-6208087e3067.gif)

```swift
struct GeometryReaderBootCamp: View {
// MARK: -  BODY
var body: some View {
ScrollView(.horizontal, showsIndicators: false) {
HStack {
ForEach(0..<20) { index in
  GeometryReader { geometry in
    RoundedRectangle(cornerRadius: 20)
      .rotation3DEffect(Angle(degrees: getPercentage(geo: geometry) * 10), axis: (x: 0.0, y: 1.0, z: 0.0))
  }
  .frame(width: 300, height: 250)
  .padding()
}
} //: HSTACK
} //: SCROLL
}
// MARK: -  FUNCTION
func getPercentage(geo: GeometryProxy)-> Double {
  let maxDistance = UIScreen.main.bounds.width / 2
  let currentX = geo.frame(in: .global).midX
  return Double(1 - (currentX / maxDistance))
}
}
```

  <img height="350"  alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫" src="https://user-images.githubusercontent.com/28912774/157374782-98714811-673c-4173-82bc-ef5d7395b398.gif">

---

### 07.Present multiple sheets from a single view

Use a sheet modifier they try to add some conditional logic in the sheet and then go to present a second or third screen it's wring screen

#### 1. Use a binding

Îã®Ï†êÏùÄ nextScreen Ïù¥ Î≥µÏû°Ìï¥ÏßÄÍ≥† Î≥ÄÏàòÍ∞Ä ÎßéÏùÑ Í≤ΩÏö∞ÏóêÎäî ÏùºÏùºÌûà Îã§ binding Ìï¥Ï§òÏïº ÎêòÏÑú code Í∞Ä Î≥µÏû°Ìï¥Ïßê

```swift
import SwiftUI

// 1 - Use a binding

// MARK: -  MODEL
struct RandomModel: Identifiable {
	let id = UUID().uuidString
	let title: String
}

struct MultipleSheetBootCamp: View {
// MARK: -  PROPERTY
@State var selectedModel: RandomModel = RandomModel(title: "Starting Title")
@State var showSheet: Bool = false
@State var selectedIndex: Int = 0


// MARK: -  BODY
var body: some View {
VStack (spacing: 20) {
  Button {
    selectedIndex = 1
    selectedModel = RandomModel(title: "One")
    showSheet.toggle()
  } label: {
    Text("Button 1")
  }

  Button {
    selectedIndex = 2
    selectedModel = RandomModel(title: "Two")
    showSheet.toggle()
  } label: {
    Text("Button 2")
  }
} //: VSTACK
.sheet(isPresented: $showSheet) {
  // selectedModel Ïù¥ Ïù¥ÎØ∏ Ï¥àÍ∏∞Í∞í ÏÉÅÌÉú (starting Title) Ïù∏ÏÉÅÌÉú ÏóêÏÑú ÎÑòÏñ¥Í∞ÄÍ∏∞ ÎïåÎ¨∏Ïóê sheet ÏùÑ Îã´ÏùÄÎã§ÏùåÏóê
  // Îã§Ïãú Ïó¥Ïñ¥ÏïºÏßÄ title Ïù¥ ÏóÖÎç∞Ïù¥Ìä∏Í∞Ä Îê®
  // 1Î≤àÏß∏ Î∞©Î≤ï: Use a binding - Îã®Ï†êÏùÄ nextScreen Ïù¥ Î≥µÏû°Ìï¥ÏßÄÍ≥† Î≥ÄÏàòÍ∞Ä ÎßéÏùÑ Í≤ΩÏö∞ÏóêÎäî ÏùºÏùºÌûà Îã§ binding Ìï¥Ï§òÏïº ÎêòÏÑú code Í∞Ä Î≥µÏû°Ìï¥Ïßê
  NextScreen(selectedModel: $selectedModel)
}
}
}

// MARK: -  NEXTSCREEN
struct NextScreen: View {

@Binding var selectedModel: RandomModel

var body: some View {
  Text(selectedModel.title)
    .font(.largeTitle)
}
}
```

#### 2. Use multiple sheets

Creating two sheets all you have to do is make sure they are not in the same hierarchy of each other

```swift
import SwiftUI

// 2 - Use multiple .sheets

// MARK: -  MODEL
struct RandomModel: Identifiable {
let id = UUID().uuidString
let title: String
}

struct MultipleSheetBootCamp: View {
// MARK: -  PROPERTY
@State var selectedModel: RandomModel = RandomModel(title: "Starting Title")
@State var showSheet: Bool = false
@State var showSheet2: Bool = false


// MARK: -  BODY
var body: some View {
VStack (spacing: 20) {
  Button {
    showSheet.toggle()
  } label: {
    Text("Button 1")
  }
  .sheet(isPresented: $showSheet) {
    NextScreen(selectedModel: RandomModel(title: "One"))
  }

  Button {
    showSheet2.toggle()
  } label: {
    Text("Button 2")
  }
  .sheet(isPresented: $showSheet2) {
    NextScreen(selectedModel: RandomModel(title: "Two"))
  }
} //: VSTACK
}
}

// MARK: -  NEXTSCREEN
struct NextScreen: View {

let selectedModel: RandomModel

var body: some View {
Text(selectedModel.title)
  .font(.largeTitle)
}
}
```

#### 3. Use $item

2Î≤à Î∞©Î≤ïÏóêÏÑú multiple .sheets Î•º ÏÇ¨Ïö©ÌïòÎ©¥ Ìï¥Í≤∞ ÎêòÏßÄÎßå ÎßåÏïΩ ÌïÑÏöîÎ°ú ÌïòÎäî sheet Ïùò Í∞ØÏàòÍ∞Ä ÎßéÏïÑÏßÄÎ©¥ ÏùºÏùºÌûà Îã§ ÎßåÎì§Ïñ¥Ïïº ÎêòÍ∏∞ ÎïåÎ¨∏Ïóê, $item Î∞©Î≤ïÏúºÎ°ú multiple .sheet ÏùÑ ÎßåÎì§ Ïàò ÏûàÏäµÎãàÎã§

```swift
import SwiftUI

// 3 - Use $item

// MARK: -  MODEL
struct RandomModel: Identifiable {
let id = UUID().uuidString
let title: String
}

struct MultipleSheetBootCamp: View {
// MARK: -  PROPERTY
@State var selectedModel: RandomModel? = nil


// MARK: -  BODY
var body: some View {
ScrollView(.vertical, showsIndicators: false) {
VStack (spacing: 20) {
  // Î≤ÑÌäº 50Í∞ú ÏÉùÏÑ±
  ForEach(0..<50) { index in
    Button {
      selectedModel = RandomModel(title: "\(index)")
    } label: {
      Text("Button \(index)")
    }
  }
} //: VSTACK
.sheet(item: $selectedModel) { model in
  NextScreen(selectedModel: model)
}
} //: SCROLL
}
}

// MARK: -  NEXTSCREEN
struct NextScreen: View {

let selectedModel: RandomModel

var body: some View {
Text(selectedModel.title)
.font(.largeTitle)
}
}

```

  <img height="350"  alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫" src="https://user-images.githubusercontent.com/28912774/157386876-d5d07e7f-0fa1-483e-a6be-e434994090fa.gif">

---

### 08.mask

We have one view that is on the bottom then another view that's on the top and then we can mask the top view so that it confirms to the same shape as the bottom view -> Thiis is the mask modifier

```swift
// mask Î•º ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÍ≥†,  ÌÅ¥Î¶≠Ïãú Î≥Ñ ÏÉâ Î∞îÎÄåÍ≤å ÎßåÎì§Í∏∞
struct MaskBootCamp: View {
	// MARK: -  PROPERTY
@State var rating: Int = 3

// MARK: -  BODY
var body: some View {
ZStack {
HStack {
ForEach(1..<6) { index in
  Image(systemName: "star.fill")
    .font(.largeTitle)
    .foregroundColor(rating >= index ? Color.yellow : Color.gray)
    .onTapGesture {
      rating = index
    }
} //: LOOP
} //: HSTACK
} //: ZSTACK
}
}
```

  <img height="350"  alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫" src="https://user-images.githubusercontent.com/28912774/157586084-89a96a9c-e89d-409f-8751-9177c6955c7d.gif">

```swift
struct MaskBootCamp: View {
// MARK: -  PROPERTY
@State var rating: Int = 0

// MARK: -  BODY
var body: some View {
ZStack {
starsView
.overlay(
  overlayView
    .mask(starsView)
)
} //: ZSTACK
}

private var overlayView: some View {
GeometryReader { geometry in
ZStack(alignment: .leading) {
Rectangle()
  .foregroundColor(.yellow)
  .frame(width: CGFloat(rating) / 5 * geometry.size.width)
} //: ZSTACK
} //: GEOMETRY
.allowsHitTesting(false)
}

private var starsView: some View {
HStack {
ForEach(1..<6) { index in
Image(systemName: "star.fill")
  .font(.largeTitle)
  .foregroundColor(Color.gray)
  .onTapGesture {
    withAnimation(.easeInOut) {
      rating = index
    }
  }
} //: LOOP
} //: HSTACK
}
}
```

## <img height="350"  alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫" src="https://user-images.githubusercontent.com/28912774/157588713-c3c41f0d-38a7-44ed-957b-53161850406c.gif">

### 09.Sound effects

```swift
import SwiftUI
import AVKit


// MARK: -  VIEWMODEL

class SoundManager: ObservableObject {

var player: AVAudioPlayer?

enum SoundOption: String {
case tada
case badum
}

func playSound(sound: SoundOption) {

guard let url = Bundle.main.url(forResource: sound.rawValue, withExtension: ".mp3") else { return }

do {
  player = try AVAudioPlayer(contentsOf: url)
  player?.play()
} catch let error {
  print("Error playing sound. \(error.localizedDescription)")
}
}
}

struct SoundBootCamp: View {
@StateObject var vm: SoundManager = SoundManager()

// MARK: -  BODY
var body: some View {
VStack (spacing: 40) {
  Button {
    vm.playSound(sound: .tada)
  } label: {
    Text("Play sound 1")
  }

  Button {
    vm.playSound(sound: .badum)
  } label: {
    Text("Play sound 2")
  }
} //: VSTACK
}
}

```

---

### 10.Haptic and vibrations

In iOS when user clicks or error message you can add vibrations to the device

```swift
import SwiftUI


class HapticManager {
	static let instance = HapticManager() // Singleton

	func notification(type: UINotificationFeedbackGenerator.FeedbackType) {
		let generator = UINotificationFeedbackGenerator()
		generator.notificationOccurred(type)
	}

	func impact(style: UIImpactFeedbackGenerator.FeedbackStyle) {
		let generaotr = UIImpactFeedbackGenerator(style: style)
		generaotr.impactOccurred()
	}
}

struct HapticsBootCamp: View {
	var body: some View {
		VStack (spacing: 20) {
			Button("success") { HapticManager.instance.notification(type: .success) }
			Button("warning") { HapticManager.instance.notification(type: .warning) }
			Button("error") { HapticManager.instance.notification(type: .error) }

			Divider()

			Button("soft") { HapticManager.instance.impact(style: .soft) }
			Button("light") { HapticManager.instance.impact(style: .light) }
			Button("medium") { HapticManager.instance.impact(style: .medium) }
			Button("rigid") { HapticManager.instance.impact(style: .rigid) }
			Button("heavy") { HapticManager.instance.impact(style: .heavy) }
		}
	}
}
```

  <!-- <img height="350"  alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫" src=""> -->

---

### 11.Local notifications

Local notifications we can actually set up and create within the application ourselves while the real push notifications are coming from a server

For example, local notification that occurs every monday or every day at 5:00 pm like application we have all of the data to know exactly when to send all of those notifications

But, if you want notifications to happen based on other user interactions like shut down server to notice users urgently you actually need a server and there's a lot more logic involved.

There are three trigger based on time, calendar, location

```swift

import SwiftUI
import UserNotifications
import CoreLocation

class NotificationManager {
static let instance = NotificationManager() // Singleton

func requestAuthorization() {
  let options: UNAuthorizationOptions = [.alert, .sound, .badge]

  UNUserNotificationCenter.current().requestAuthorization(options: options) { (success, error)  in
    if let error = error {
      print("ERROR: \(error)")
    } else {
      print("SUCCESS")
    }
  }
}

func scheduleNotification() {
  let content = UNMutableNotificationContent()
  content.title = "This is my first notification"
  content.subtitle = "This is sooo easy!"
  content.sound = .default
  content.badge = 1

  // 3 trigger type

  // time
  // let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 3.0, repeats: false)

  // calendar
  // var datecomponents = DateComponents()
  // datecomponents.hour = 20
  // datecomponents.minute = 26
  // datecomponents.weekday = 1 // 1ÏùÄ ÏùºÏöîÏùº, 6ÏùÄ Í∏àÏöîÏùºÏùº Îê®
  // let trigger = UNCalendarNotificationTrigger(dateMatching: datecomponents, repeats: true)

  // location
  let cordinates = CLLocationCoordinate2D(
    latitude: 40.00,
    longitude: 50.00)

  let region = CLCircularRegion(
    center: cordinates,
    radius: 100,
    identifier: UUID().uuidString)

  region.notifyOnEntry = true // ÌòÑÏû¨ ÏúÑÏπòÏóêÏÑú cordinate ÏßÄÏ†ïÌïú ÏúÑÏπòÎ°ú Îì§Ïñ¥Ïò¨Îïå region ÌôúÏÑ±Ìôî
  region.notifyOnExit = true // ÌòÑÏû¨ ÏúÑÏπòÏóêÏÑú cordinate ÏßÄÏ†ïÌïú ÏúÑÏπòÎ°ú ÎÇòÍ∞àÎïå region ÌôúÏÑ±Ìôî

  let trigger = UNLocationNotificationTrigger(region: region, repeats: true)

  let request = UNNotificationRequest(
    identifier: UUID().uuidString,
    content: content,
    trigger: trigger)
  UNUserNotificationCenter.current().add(request)
}

func cancelNotification() {
  UNUserNotificationCenter.current().removeAllPendingNotificationRequests()
  UNUserNotificationCenter.current().removeAllDeliveredNotifications()
}
}

struct NotificationBootCamp: View {
var body: some View {
VStack (spacing: 40) {
  Button("Request Permission") {
    NotificationManager.instance.requestAuthorization()
  }
  Button("Schedile notification") {
    NotificationManager.instance.scheduleNotification()
  }

  Button("Cancel notification") {
    NotificationManager.instance.cancelNotification()
  }
} //: VSTACK
.onAppear {
  // App Ïù¥ Ïó¥Î¶¨Î©¥ badge number Î•º 0ÏúºÎ°ú Ìï¥Ï§å
  UIApplication.shared.applicationIconBadgeNumber = 0
}
}
}
```

  <!-- <img height="350"  alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫" src=""> -->

---

### 12.Hashable

```swift
import SwiftUI

// Model
// 2-1
// Î™®Îç∏ÏùÑ ÏÇ¨Ïö©Ìï†Í≤ΩÏö∞ hashValue Î•º ÏÇ¨Ïö©ÌïòÎ†§Î©¥ hashable protocol ÏùÑ ÏÇ¨Ïö©ÌïòÎ©¥ Îê©ÎãàÎã§. Ï£ºÎ°ú ID Í∞íÏù¥ ÏûàÎäî Í≤ΩÏö∞Í∞Ä ÎßéÍ∏∞
// ÎïåÎ¨∏Ïóê Identifiable protocol ÏùÑ ÏÇ¨Ïö©Ìï©ÎãàÎã§(Í∑∏Îü¨Î©¥ Î∞òÎìúÏãú Î™®Îç∏Ïóê ID Í∞íÏù¥ ÏûàÏñ¥Ïïº Ìï©ÎãàÎã§)
struct MyDateModel1: Identifiable {
	let id =  UUID().uuidString // id Í∞íÏùÄ UUID() ÏùÑ ÏÇ¨Ïö©ÌïòÎ©¥ swift ÏóêÏÑú random ID ÏùÑ ÏÉùÏÑ±ÌïòÍ≥† String ÌÉÄÏûÖÏúºÎ°ú Î∞îÍøî Ï§çÎãàÎã§
	// ÎßåÏïΩ Îç∞Ïù¥ÌÑ∞ Î™®Îç∏Ïóê id Í∞íÏù¥ ÏûàÎã§Î©¥ hashable protocol ÏùÑ ÏÇ¨Ïö©Ìï† ÌïÑÏöîÍ∞Ä ÏóÜÏäµÎãàÎã§.
	let title: String
}

struct MyDateModel2: Hashable {
	let title: String

	// hash valse Í∞íÏùÑ ÏÉùÏÑ±Ìï¥Ï£ºÎäî Ìï®ÏàòÎ•º ÎßåÎì§Ïñ¥ Ï§òÏïº Ìï©ÎãàÎã§
	// hash into inout Ìï®ÏàòÎ•º ÎßåÎì§Ïñ¥ Ï£ºÍ≥†,
	func hash(into hasher: inout Hasher) {
		hasher.combine(title) // Ïù¥Î†áÍ≤å ÌïòÎ©¥ hash Ïùò Í≥†Ïú†Ïùò hash value Í∞íÏù¥ ÏÉùÏÑ±Ïù¥ Îê©ÎãàÎã§. Îã®Ï†êÏùÑ title Ïùò Í∞íÏù¥
		// Ï§ëÎ≥µÏù¥ ÎêòÎ©¥ hasher Ïùò Í∞íÏù¥ Í∞ôÏïÑÏßÄÍ∏∞ ÎïåÎ¨∏Ïóê ÏÇ¨Ïö©ÌïòÎ†§Î©¥ Ï§ëÎ≥µÏùò Í∞íÏù¥ ÏóÜÏñ¥Ïïº Ìï©ÎãàÎã§
	}
}


struct HashableBootCamp: View {

	// 1-1. Î®ºÏ†Ä ÏöîÏùºÎç∞Ïù¥ÌÑ∞ Î≥ÄÏàòÎ•º ÎßåÎì§Ïñ¥ Î≥¥Í≤†ÏäµÎãàÎã§
	let dateArray1: [String] = [
		"ÏùºÏöîÏùº", "ÏõîÏöîÏùº", "ÌôîÏöîÏùº", "ÏàòÏöîÏùº", "Î™©ÏöîÏùº", "Í∏àÏöîÏùº", "ÌÜ†ÏöîÏùº"
	]

	// 2-1. Î™®Îç∏ÏùÑ ÏÇ¨Ïö©Ìï¥ÏÑú Îç∞Ïù¥ÌÑ∞ ÎßåÎì§Í∏∞
	let dateArray2: [MyDateModel1] = [
		MyDateModel1(title: "ÏùºÏöîÏùº"),
		MyDateModel1(title: "ÏõîÏöîÏùº"),
		MyDateModel1(title: "ÌôîÏöîÏùº"),
		MyDateModel1(title: "ÏàòÏöîÏùº"),
		MyDateModel1(title: "Î™©ÏöîÏùº"),
		MyDateModel1(title: "Í∏àÏöîÏùº"),
		MyDateModel1(title: "ÌÜ†ÏöîÏùº")
	]

	// 3-1. Hashable protocol ÏÇ¨Ïö©
	let dateArray3: [MyDateModel2] = [
		MyDateModel2(title: "ÏùºÏöîÏùº"),
		MyDateModel2(title: "ÏõîÏöîÏùº"),
		MyDateModel2(title: "ÌôîÏöîÏùº"),
		MyDateModel2(title: "ÏàòÏöîÏùº"),
		MyDateModel2(title: "Î™©ÏöîÏùº"),
		MyDateModel2(title: "Í∏àÏöîÏùº"),
		MyDateModel2(title: "ÌÜ†ÏöîÏùº")
	]

	var body: some View {

		// Part 1. Basic hashable

		// 2. Ïä§ÌÅ¨Î°§Î∑∞ ÎßåÎì§Ïñ¥Ï£ºÍ≥†, Í∑∏ ÏïàÏóê vstack ÎßåÎì§Í≥† Í∑∏ ÏïàÏóê data Î•º forEach Î°ú Î∞òÎ≥µÎ¨∏ÏùÑ ÎèåÎ†§ Ï§çÎãàÎã§
		ScrollView {
			VStack (spacing: 20) {
				// 3. ForEach ÏóêÏÑú data, id, content parameter Í∞Ä ÏûàÎäîÍ≤ÉÏùÑ ÏÑ†ÌÉù Ìï¥ Ï§çÎãàÎã§. dataArray ÎÑ£Ïñ¥Ï£ºÍ≥†
				// 4. id Îäî ÏûêÍ∏∞ÏûêÏã†Ïùò Í≥†Ïú†Í∞íÏù¥ Îê†Ïàò ÏûàÍ≤å \.self Ìï¥Ï§çÎãàÎã§ (Ïù¥Í≤ÉÏùÑ ÌïòÍ≤åÎêòÎ©¥, Î∞òÎ≥µÎ¨∏ÏùÑ ÎèåÎïå Í∑∏ ÌïòÎÇòÏùò object ÎßàÎã§ id Í∞íÏùÑ Î∂ÄÏó¨ÌïòÍ≤å ÎêòÎäîÍ≤ÉÏûÖÎãàÎã§
				// 5. Enter ÎàÑÎ£®Í≥† item in Ìï¥Ï£ºÎ©¥ Î∞òÎ≥µÎ¨∏Ïù¥ ÎèåÎñº ÎßàÍ∞Ä Í∑∏ ÌïòÎÇòÏùò Ïò§Î∏åÏ†ùÌä∏ Í∞íÏù¥ item Ïù¥ÎùºÎäî Î≥ÄÏàòÎ°ú Î∂àÎ¶¥ Ïàò ÏûàÍ≤å ÎêòÏÑú Í±∞Í∏∞Ïóê Ï†ëÍ∑ºÌï† Ïàò ÏûàÍ≤å Îê©ÎãàÎã§
				ForEach(dateArray1, id: \.self) { item in
					Text(item)
						.font(.headline)
					// 6. ÏúÑÏôÄ Í∞ôÏù¥ ÌïòÎ©¥ Í∞ÅÍ∞ÅÏùò item Îì§ÏùÄ Í≥†Ïú†Ïùò hash value Í∞ëÏùÑ Í∞ÄÏßà Ïàò ÏûàÍ≤å Îê©ÎãàÎã§

					Text(item.hashValue.description)
						.font(.headline)
					// Í∞ÅÍ∞ÅÏùò item Í∞íÏóê hash Í∞íÏùÑ ÌôîÎ©¥Ïóê ÌëúÏãú Ìï† Ïàò ÏûàÏäµÎãàÎã§. Í∞ÅÍ∞ÅÏùò Í∞íÏù¥ Îã§Î•∏Í≤å Î≥¥Ïù¥ÏãúÏ£†?
					// ÏúÑÏùò hash Í∞íÎì§ÏùÄ Î∞òÎ≥µÎ¨∏ÏùÑ ÎèåÎ©¥ÏÑú ÌîÑÎ°úÍ∑∏Îû®ÏóêÏÑú ÎûúÎç§ ÌïòÍ≤å Í∞ÅÍ∞ÄÏùò Í∞íÎì§Ïóê Í≤å Í≥†Ïú†Ïùò Ïà´Ïûê Í∞íÏùÑ Î∂ÄÏó¨ Ìï©ÎãàÎã§
				}
			}
		}

		// Part 2. Model ÎßåÎì§Ïñ¥ÏÑú identifiable protocol ÏÇ¨Ïö©ÌïòÍ∏∞
		ScrollView {
			VStack (spacing: 20) {
				// 2-3
				// Ïù¥ÎØ∏ model Ïóê id Í∞íÏù¥ ÏûàÍ∏∞ ÎïåÎ¨∏Ïóê ÏúÑÏôÄ Í∞ôÏù¥ \.self Í∞íÏùÑ Ïïà ÎÑ£Ïñ¥ Ï§òÎèÑ Îê©ÎãàÎã§
				ForEach(dateArray2) { item in
					Text(item.title)
						.font(.headline)
					Text(item.id) // UUID Î°ú ÏÉùÏÑ±Ìïú ID
				}
				// Ïù¥Î†áÍ≤å ÏÇ¨Ïö©ÌïòÎ©¥ part 1. ÏóêÏÑú ÎßåÎì§ Í≤ÉÍ≥º ÎπÑÏä∑ÌïòÍ≤å hash Í∞íÏù¥ Í≥†Ïú†Ïùò ID Í∞íÏù¥ ÎêòÏñ¥ÏÑú ÏÇ¨Ïö©Ìï† Ïàò ÏûàÍ≤å Îê©ÎãàÎã§
			}
		}

		// Part 3. Hashable protocol ÏÇ¨Ïö©ÌïòÍ∏∞
		// ÎßåÏïΩ Model Ïóê ID Í∞íÏù¥ ÏóÜÎäîÍ≤ΩÏö∞ UUID() Î•º ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÍ≥† hashable protocol ÏùÑ ÏÇ¨Ïö©Ìï¥ÏÑú Í≥†Ïú†Ïùò hash value Í∞íÏùÑ ÏÇ¨Ïö©ÌïòÎäî ÏòàÏãúÎ•º ÎßåÎì§Í≤†ÏäµÎãàÎã§
		ScrollView {
			VStack (spacing: 20) {
				ForEach(dateArray3, id: \.self) { item in
					Text(item.hashValue.description)
						.font(.headline)
				}
			}
		}
		// ÏúÑÏùò ÏòàÏãúÎì§ÏùÑ Î≥¥Í≤å ÎêòÎ©¥ id Í∞íÏù¥ ÏóÜÎäî Í≤ΩÏö∞ÏóêÎäî hash Ìï®ÏàòÎ•º ÎßåÎì§Ïñ¥Ï§òÏÑú Í∞ÅÍ∞ÅÏùò Í≥†Ïú†Í∞íÏùÑ Î∂ÄÏó¨ Ìï† Ïàò ÏûàÏúºÎÇò,
		// UUID Î•º ÏÇ¨Ïö©Ìï¥ÏÑú Í≥†Ïú†Ïùò ID Í∞íÏùÑ Ï£ºÍ≤å ÎêòÎ©¥ Îçî Í∞ÑÌé∏Ìûà hash Í∞íÏùÑ Î∂ÄÏó¨ÌïòÎäîÍ≤ÉÍ≥º Ïú†ÏÇ¨ÌïòÍ≤å Í∞ÅÍ∞ÅÏùò Î∞òÎ≥µÎ¨∏ÏóêÏÑú Í≥†Ïú†Ïùò ID
		// Í∞íÏùÑ Ï§Ñ Ïàò ÏûàÏäµÎãàÎã§
		// ÏßÄÍ∏àÍπåÏßÄ hasherble Ïùò Í∞úÎÖê Í≥º ÏÇ¨Ïö©Î∞©Î≤ïÏóê ÎåÄÌï¥ÏÑú ÏÑ§Î™Ö ÎìúÎ†∏ÏäµÎãàÎã§. Îã§Ïùå Í∞ïÏùòÏóêÏÑú ÎµôÍ≤†ÏäµÎãàÎã§. Í∞êÏÇ¨Ìï©ÎãàÎã§
	}
}
```

<p>
<img width="350" alt="image" src="https://user-images.githubusercontent.com/28912774/159608391-4fa07caf-923f-4ea9-bab8-3c390af5ff26.png">
<img width="350" alt="image" src="https://user-images.githubusercontent.com/28912774/159608446-0692fac8-abc4-4f68-abdd-301230d9a7f9.png">
<img width="350" alt="image" src="https://user-images.githubusercontent.com/28912774/159608515-731438b0-f2f2-4c32-8cd5-38307e58db57.png">

</p>

---

### 13.Sort, Filter and Map

```swift

```

  <img height="350"  alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫" src="">

---

### 14.Core Data

#### FetchRequest

```swift

```

  <img height="350"  alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫" src="">

#### Core Data with MVVM

```swift

```

  <img height="350"  alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫" src="">

#### Core Data with relationships

```swift

```

  <img height="350"  alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫" src="">

---

### 15.Background threads and Queues

```swift

```

  <img height="350"  alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫" src="">

---

### 16.Weak self

```swift

```

  <img height="350"  alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫" src="">

---

### 17.Typealias

```swift

```

  <img height="350"  alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫" src="">

---

### 18.Escaping

```swift

```

  <img height="350"  alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫" src="">

---

### 19.Codable

```swift

```

  <img height="350"  alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫" src="">

---

### 20.Downland Json

#### Downland Json with escaping

```swift

```

  <img height="350"  alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫" src="">

#### Downland Json with Combine

```swift

```

  <img height="350"  alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫" src="">

---

### 21.Timer and onReceive

```swift

```

  <img height="350"  alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫" src="">

---

### 22.Custom publishers and Subscribers in Combine

```swift

```

  <img height="350"  alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫" src="">

---

### 23.FileManager

```swift

```

  <img height="350"  alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫" src="">

---

### 24.NSCache

```swift

```

  <img height="350"  alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫" src="">

---

### 25.Download and Save images

```swift

```

  <img height="350"  alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫" src="">

---

###

```swift

```

  <img height="350"  alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫" src="">

---

<!-- <p align="center">
  <img height="350"  alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫" src="">
</p> -->

<!-- README Ìïú Ï§ÑÏóê Ïó¨Îü¨ screenshoot ÎÜìÍ∏∞ ÏòàÏ†ú -->
<!-- <p>
   <img height="350" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫" src="">
   <img height="350" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫" src="">
   <img height="350" alt="·Ñâ·Ö≥·Ñè·Ö≥·ÑÖ·Öµ·Ü´·Ñâ·Ö£·Ü∫" src="">
</p> -->

---

<!-- üî∂ üî∑ üìå üîë üëâ -->

## üóÉ Reference

SwiftUI Continued Learning (Intermediate Level) - [https://www.youtube.com/c/SwiftfulThinking](https://www.youtube.com/c/SwiftfulThinking)
